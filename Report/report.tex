
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{url}
\usepackage{xcolor}
\usepackage{acro}


\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\usepackage{nameref}
\acsetup{first-style=short}

% Abbreviations
\DeclareAcronym{dp}{short = DP, long = Draw Pile Module, class = abbrev}
\DeclareAcronym{fp}{short = FP, long = Foundation Pile Module, class = abbrev}
\DeclareAcronym{tp}{short = TP, long = Tableau Pile Module, class = abbrev}
\DeclareAcronym{p}{short = P, long = Player Module, class = abbrev}
\DeclareAcronym{pb}{short = PB, long = Player Bot Module, class = abbrev}
\DeclareAcronym{fifo}{short = FIFO, long = First In First Out (Queue), class = abbrev}
\DeclareAcronym{lifo}{short = LIFO, long = Last In First Out (Stack), class = abbrev}
\DeclareAcronym{gui}{short = GUI, long = Graphical User Interface, class = abbrev}

% Nomenclature
\DeclareAcronym{card}{short = card, long = (In the Petri Net context) A token with a color which represents a card in the deck., class = nomencl}
\DeclareAcronym{command}{short = command, long = A token with a color which represents a turn or movement command., class = nomencl}

\newcommand{\GPenSIM}{../GPenSIM}
\definecolor{matlabcomment}{RGB}{34,139,34}
\definecolor{matlabstring}{RGB}{160,32,240}
\definecolor{matlabkeyword}{RGB}{0,0,255}
\lstdefinestyle{matlabcode}{
	language=Matlab,
	frame=single,
	%caption=\lstname,
	stringstyle=\color{matlabstring},
	keywordstyle=\color{matlabkeyword},
	commentstyle=\color{matlabcomment},
	basicstyle=\fontsize{6}{7}\selectfont,%\tiny
	breaklines=true,
	numbers=left
}


\begin{document}
\mainmatter  % start of an individual contribution
% first the title is needed
\title{DAT530\\Discrete Simulation and Performance Analysis\\Final Project\\Solitaire game strategy}
% a short form should be given in case it is too long for the running head
\titlerunning{DAT530 - Final Project}
\author{Racin W. Nygaard}
\authorrunning{DAT530 - Final Project - Solitaire game strategy}
% (feature abused for this document to repeat the title also on left hand pages)
\institute{Universitetet i Stavanger}

\toctitle{Abstract}
\tocauthor{ }
\maketitle
	


\begin{abstract}
This project is such and such... +++

\end{abstract}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\tableofcontents
\listoffigures
\listoftables
\printacronyms[name=Abbreviations,include-classes=abbrev]
\printacronyms[name=Nomenclature,include-classes=nomencl]
\section{Introduction}
This project aims to study the popular card game, Solitaire[Site]. Solitaire is bundled with most Windows[Site] installations, as well as being available for free on several sources. It is also easy to play the game with a physical card deck. A detailed explanation of the games rules can be found in the next chapter, Solitaire Rules[REF]
\newline
Since the game utilizes all 52 cards of the deck, the number of possible initial game states is 52!, which is a very high number. A large number of these inital game states can be merged, as they offer no difference in the difficulty to solve. Some of these initial states are unsolvable, but even given a solvable game state, one often find oneself in an unsolvable game state, due to certain actions in the game are non-reversible,. There has been attempts to find the distribution of solvable and unsolvable initial game states [ref]. This is roughly 75 percent are solvable, however the study also shows that only 35 percent of the games are won by an experienced player.
\newline
This project contains a complete model of the game, a GUI to play the game, and a basic bot to simulate user actions. 

\subsection{Solitaire Rules}
\label{sec1:solitaire_rules}
Klondike, or Solitaire as it has been called in North America is one of the most popular patience games.
\newline
 The game became very popular in the 19th century and the name Klondike is believed to have originated from the prospectors that were mining for gold in the Klondike region in Canada, and whom have either created or promoted this game while on their quest. 
 \newline
 
Solitaire is played with a standard deck of 52 cards and no Jokers.
We will describe the layout and rules of the game by using terms that are common to the majority of patience games.
\newline

Foundations are commonly featured in patience games where the aim is to move all the cards from the board to the foundation piles. Foundation piles are typically built from the foundation card by suit.
In Solitaire, the four Aces in the deck are the foundation cards with corresponding foundation piles. We build up the piles by stacking cards of the same suit starting from Ace and finishing with King. 
\newline

 At the beginning of the game, the deck is shuffled and the cards are laid out in seven piles from left to right. Each pile contains one additional card compared to the previous one. 
 There is one upturned card at the beginning of each pile. The first pile to the left contains one card facing up, the second contains one card facing down and one up, the third pile contains two cards facing down and one up, and so on to the seventh pile which contains six cards facing down and one facing up.
 card, the second pile contains two cards and so on up to the seventh pile which contains seven cards. These are called tableau piles. 
 Tableau piles can be built down by alternating colors. Partial or complete piles can be moved on top of other piles as long as the 
 We consider the four aces in the deck as foundation cards with corresponding foundation piles. These piles are built up by stacking cards of the same suit starting from ace.
The tableau piles, foundation piles, turn pile and their layout are illustrated in figure \ref{fig:illuatration_solitaire}.
\begin{figure}
	 % Left, Bottom, Right, Top
	\includegraphics[trim=150 0 0 0, scale=0.3]{images/TableauPiles}
	\caption{Illustration of card layout in Solitaire}
	\label{fig:illuatration_solitaire}
\end{figure}


\section{Method and Design}
\label{sec:2_method_and_design}
\subsection{Naming Policy}
\subsection{File structure}
\label{sec:2_file_structure}
To reduce the number of files, most of the pre- and post-processor files of the \ac{fp} and \ac{tp} modules have been combined in one single file. An example of this can be shown in listing \ref{lst:COMMON_PRE}, which shows parts of \verb!COMMON_PRE!
\lstinputlisting[style=matlabcode,caption=COMMON\_PRE.m lines 1-5,label=lst:COMMON_PRE,lastline=5]{\GPenSIM/COMMON_PRE.m}

By doing this it is possible to reduce the number of files required without overloading the \verb!COMMON_PRE! and \verb!COMMON_POST! files. It also makes it much easier to work and maintain the code as the logic is only located in one place, as opposed to four or seven places if each transition had their own file.
\newline

With this approach it is no longer possible to hard-code the names of the related transitions and places, so two additional functions; \verb!get_tableau_from_transname! and \verb!get_suit_from_transname! were developed. These functions take the name of the transition as input, and then return the unique identifier for which module it belongs to. The actual code is pretty simple, and parts of \verb!get_suit_from_transname! is shown in listing \ref{lst:get_suit_from_transname}. The reasoning behind not using the Matlab command \verb!contains! is simply that it is not supported in older versions.
\lstinputlisting[style=matlabcode,caption=get\_suit\_from\_transname.m lines 7-17,label=lst:get_suit_from_transname,firstline=7,lastline=17]{\GPenSIM/get_suit_from_transname.m}
\clearpage
\subsection{Overall Design}

\begin{figure}
	\begin{center} % Left, Bottom, Right, Top
		\includegraphics[trim=250 260 230 330,scale=1.1]{images/overallViewPdf}
		\caption{The complete model - Without the internal components of the modules.}
		\label{fig:full_horizontal}
	\end{center}
\end{figure}


The model developed is pretty large, and contains 94 transition and 42 places. It is developed using the modular approach, and encompasses 6 different modules. Some of the modules are duplicated, with the only difference being the names of the transitions and places.
\newline

\subsection{Draw Pile Module}
\label{sec:draw_pile}
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/drawPile}
		\caption{Draw Pile Module}
		\label{fig:draw_pile}
	\end{center}
\end{figure}
The Draw Pile module is depicted in figure \ref{fig:draw_pile}, and has several key responsibilities, once of which is to do the initial dealing of cards. In order to preserve the correctness of the gameplay, external input is not allowed during this phase. When first running the model, all the initial tokens of \verb!pDP_Dealer! will be sent to \verb!tDPi_Dealer!. This transition will give each token a color which represents a \ac{card} in the deck. Possible colors are initially stored in the cell \verb!global_info.DECK!. If \verb!global_info.RANDOM_DECK! is set, a random permutation of the colors will be given to the tokens. By having \verb!global_info.RANDOM_DECK! set to false, it is possible to run analytics which require that the cards are dealt equally each time.
\newline

After all tokens are given a color, \verb!tDPi_Turn! will be enabled. This transition will move cards from the pile which represents face-down cards, \verb!pDP_Draw_FaceDown_Pile! to the one representing face-up cards, \verb!pDP_Draw_FaceUp_Pile!. This transition will fire as many times as the length of \verb!global_info.INITIAL_DEAL_MOVE!, which is 28 in a normal game. This is not something that would be done if the game where played with physical cards, as they would just be dealt without turning them. In this model however, this is required so that existing logic could be re-used.
\newline

Concurrently to the firing of \verb!tDPi_Turn!, the transition \verb!tDPi_Move_Init! will fire an equal amount of times. The transition will give each of the tokens in \verb!pDP_Move_Init! a color which represents to which tableau pile the \ac{card} should be moved to. The color given to each token is augmented by the cell, \verb!global_info.INITIAL_DEAL_MOVE!. An example of a color given is \emph{Move:\ac{tp}1:\ac{dp}} which means; \textit{Moving a card from source DP to destination \ac{tp}1}. Every time a \ac{card} reaches its destined tableau pile, the variable \verb!global_info.CARDS_DEALT! will be incremented by one in \verb!COMMON_POST!. Once it becomes equal to the length of \verb!global_info.INITIAL_DEAL_MOVE!, the initial dealing phase is over, and the normal phase starts.
\newline

During the normal phase, external input is allowed. The first input of the Draw Pile Module is \verb!tDPe_Move!. This transition has an pre-processor file, which makes it only fire if there are tokens in \verb!pDP_Draw_FaceUp_Pile!. Additionally, the Player and Player Bot modules ensures that the enabling token has color on the format \textit{Move:(destination):\ac{dp}}.
\lstinputlisting[style=matlabcode,caption=tDPe\_Move\_pre.m,label=lst:tDPe_Move_pre]{\GPenSIM/tDPe_Move_pre.m}

The second input, \verb!tDPe_Turn! is used to used to simply move cards from the face-down pile to the face-up pile during the normal phase. An interesting thing about this is that once all the cards are in the face-up pile, the next time one attempts to turn a \ac{card}, all cards should be moved back to the face-down pile in \ac{lifo} style, just as they would if you simply flip the deck of cards around in real-life. 
\newline
This is accomplished by the transitions \verb!tDPi_Flip_Pile! and \verb!tDPi_Enable_DP_Trans!. The \verb!tDPi_Enable_FP_Trans! is actually a siphon, and becomes enabled once \verb!pDP_Draw_FaceDown_Pile! is empty, and there is an active turn action on-going so that \verb!pDP_Turn! has at least one token. The transition has one post-processor file, shown in listing \ref{lst:tDPi_Enable_FP_Trans_post}. Given that there are actually any tokens left in \verb!pDP_Draw_FaceUp_Pile! it will set the global flag, \verb!global_info.DP_Flip_Pile_Running! to \verb!true!, if there are no tokens in the face-up pile, it will simply release the \verb!playerAction! resource. The use of resources is discussed further in chapter \ref{sec:3_Resources}. The reason for not having an arc directly from the face-up pile is due to this transition being a siphon, so the \ac{card} would be removed from the game if it fired.
\lstinputlisting[style=matlabcode,caption=tDPi\_Enable\_FP\_Trans\_post.m,label=lst:tDPi_Enable_FP_Trans_post]{\GPenSIM/tDPi_Enable_FP_Trans_post.m}
Once \verb!global_info.DP_Flip_Pile_Running! is set to \verb!true! and there are tokens in \verb!pDP_Draw_FaceUp_Pile!, the transition \verb!tDPi_Flip_Pile! will start firing. The pre-processor file is listed in \ref{lst:tDPi_Flip_Pile_pre}, and will keep selecting the latest arrived \ac{card} from \verb!pDP_Draw_FaceUp_Pile! and fire. In the post-processor file, listed in \ref{lst:tDPi_Flip_Pile_post}, it will check for the length of the face-up pile, once it becomes empty it will set the flag \verb!global_info.DP_Flip_Pile_Running! to \verb!false!, and the cards have been successfully turned around.
\lstinputlisting[style=matlabcode,caption=tDPi\_Flip\_Pile\_pre.m,label=lst:tDPi_Flip_Pile_pre]{\GPenSIM/tDPi_Flip_Pile_pre.m}
\lstinputlisting[style=matlabcode,caption=tDPi\_Flip\_Pile\_post.m,label=lst:tDPi_Flip_Pile_post]{\GPenSIM/tDPi_Flip_Pile_post.m}

Lastly, there is the \verb!tDPe_Out! transition. This is the only external output of the module. When enabled, its pre-processor will take the lastest card arrived at \verb!pDP_Draw_FaceUp_Pile!, but the earliest command arrived at \verb!pDP_Move_Out! when firing. By taking the earliest command arrived in a \ac{fifo} manner, we ensure that the inital dealing will be correct. If we were to take the latest command, we would have to add additional logic such as alternating firing to make certain the ordering of cards would be correct. The code is shown in lising \ref{lst:tDPe_Out_pre}
\lstinputlisting[style=matlabcode,caption=tDPe\_Out\_pre.m,label=lst:tDPe_Out_pre]{\GPenSIM/tDPe_Out_pre.m}
Interestingly, moving cards out of the \verb!tDPe_Out! transition is a non-reversible action as the module has no external input. So by doing this one could potentially put the game in an unsolvable state.
\begin{table}
	\caption{Places and transitions used in Draw Pile}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1  & pDP\_Dealer               & Holds the initial tokens which will become cards. \\ \hline
		2  & pDP\_Draw\_FaceDown\_Pile & Holds the face-down cards. These are not visible to the player. \\ \hline
		3  & pDP\_Draw\_FaceUp\_Pile   & Holde the face-up cards. Only the top card is visible to the player. \\ \hline
		4  & pDP\_Move\_Init           & Holds initial tokens used for generating move-commands. \\ \hline
		5  & pDP\_Move\_Out            & Buffer for move-commands.  \\ \hline
		6  & pDP\_Turn                 & Buffer for turn-commands. \\ \hline
		7  & tDPe\_Move               &   External input for the move-\ac{command} \\ \hline
		8  & tDPe\_Out                &   External output \\ \hline
		9  & tDPe\_Turn               &   External input for the turn-\ac{command} \\ \hline
		10  & tDPi\_Dealer             &   Gives every token a color to represent a card in the deck. \\ \hline
		11  & tDPi\_Enable\_FP\_Trans  &   Used to facilitate the flipping of the face-up pile. \\ \hline
		12  & tDPi\_Flip\_Pile         &   Moves cards from face-up pile to face-down pile in a \ac{lifo} manner. \\ \hline
		13  & tDPi\_Move\_Init         &   Generates initial move-commands to facilitate initial dealing of the cards. \\ \hline
		14  & tDPi\_Turn               &   Moves a card from the face-down pile to the face-up pile. \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Foundation Pile Module}
The Foundation Pile module is depicted figure \ref{fig:foundation_pile}. It is duplicated four times, once for every suit, clubs, diamonds, hearts, and spades. The only difference between these modules is the names of their respective transitions and names, so the description given for clubs will count for the other duplicates as well. All the pre- and post-processor files are shared between all the suits.
\newline
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/foundationPile}
		\caption{Foundation Pile Module}
		\label{fig:foundation_pile}
	\end{center}
\end{figure}

This module is inactive during the initial phase, and only becomes interact-able once the normal phase starts. It has two external inputs, the first of which is \verb!tFPe_Clubs_Add!. This transition has a shared pre-processor file, \verb!pre_tFPe_Add!. Listing \ref{lst:pre_tFPe_Add} shows parts of the logic, the full file can be found in \ref{app:pre_tFPe_Add}. The pre-processor fetches the token arrived earliest at \verb!pMC_Out_Buffer!. This is an important step, but is not strictly required because of the limitations the resource \verb!playerAction! enforces on the transitions of the Player and Player Bot modules. Still, it makes sense to fetch the earliest token in \ac{fifo} style to make sure that the first moved card reaches its destination first. 
\newline

Given that the colors of the token have the correct length, the \verb!get_suit_from_transname! function will be run to determine which \ac{fp} the executing transition belongs to. More information about this step can be found in \ref{sec:2_file_structure}. Lastly, the \verb!checkCommand_Move! function is ran to determine the validity of the command in the context of this particular transition. The \verb!checkCommand_Move! function is quite involved, and is discussed in detail in chapter \ref{sec:3_move_command}.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Add.m lines 5-17,label=lst:pre_tFPe_Add,firstline=5,lastline=17]{\GPenSIM/pre_tFPe_Add.m}

The second external input is \verb!tFPe_Clubs_Move!. Its used for moving cards to other modules, and works similarly to how movement in handle in the Draw Pile, with the additional caveat that all four Foundation Piles becomes enabled at the time from \verb!pMC_FP_Move!. Due to this its necessary to introduce additional logic to ensure that the issued move-command from the Player or Player Bot modules are meant for this particular module. As with the other modules, the actual validity of the move-command are handles by the \ac{p} and \ac{pb} modules.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Move.m lines 4-10,label=lst:pre_tFPe_Move,firstline=4,lastline=10]{\GPenSIM/pre_tFPe_Move.m}

The only external output of the {fp} is \verb!tFPe_Clubs_Out!. It works similarly to the output of the Draw Pile, where the pre-processor takes the latest arrived card \verb!pFP_Clubs_Pile! and the earliest arrived command from \verb!pFP_Clubs_Move!. This ensures that the first issued command will be processed first, should there be more than one. The only time there would be more than one command executing concurrently is if neither the Player or the Player Bot modules where enabled, and the command was issued from another module which did not use the \verb!playerAction! resource. Listing \ref{lst:pre_tFPe_Out} shows parts of the code.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Out.m lines 4-10,label=lst:pre_tFPe_Out,firstline=4,lastline=10]{\GPenSIM/pre_tFPe_Out.m}


Another interesting fact about the Foundation Pile modules is the place \verb!pFP_Clubs_Pile!. Once this place is filled with 13 tokens for all the suits, the game is won, and the simulation ends. There is no check done on the actual color or order of the tokens, as that is done when adding them by the pre-processor of \verb!tFPe_Clubs_Add!. The win condition can be found in \verb!COMMON_POST!. Parts of the code is shown in listing \ref{lst:COMMON_POST}.
\lstinputlisting[style=matlabcode,caption=COMMON\_POST.m lines 36-45,label=lst:COMMON_POST,firstline=36,lastline=45]{\GPenSIM/COMMON_POST.m}
\begin{table}
	\caption{Places and transitions used in Foundation Pile - Clubs}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1  & pFP\_Clubs\_Move        &  Buffer for move-\ac{command}s \\ \hline
		2  & pFP\_Clubs\_Pile        &  Holds the cards which are added to the Foundation Pile.\\ \hline
		3  & tFPe\_Clubs\_Add        &  External input for adding cards to the Foundation Pile.  \\ \hline
		4 & tFPe\_Clubs\_Move        &  External input for the move-command. \\ \hline
		5 & tFPe\_Clubs\_Out         &  External output  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Tableau Pile Module}
The Tableau Pile module is depicted in figure \ref{fig:tableau_pile}. It is duplicated 7 times, once for every pile in the tableau. The main difference between these modules is the names of their respective transitions and names, so the description given for the first pile will count for the other duplicates as well. Another difference is how many cards each pile are dealt during the initial phase. This is discussed in more detail in chapter \ref{sec:3_initial_dealing} and \ref{sec:draw_pile}. All the pre- and post-processor files are shared between all piles.
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/tableauPile}
		\caption{Tableau Pile Module}
		\label{fig:tableau_pile}
	\end{center}
\end{figure}

As with the Draw Pile module, the module encompasses both a face-down and a face-up pile. The inner workings between these two piles is different however, as moving a card from the face-down pile to the face-up pile is an non-reversible action. Doing so could put the game in an unsolvable state, but at the same time if there were no cards in any of the face-down piles the game would be trivial to solve. \\

The only time it's possible to add cards to \verb!pTP_1_FaceDown_Pile! is during the initial phase. During this phase, one less than the piles identification number will be added, so that pile one will have zero cards in the face-down pile, whilst pile 7 will have 6. All the piles will have a single card added to \verb!pTP_1_FaceUp_Pile!. This is discussed in more detail in chapter \ref{sec:3_initial_dealing}. \\

Once the initial phase is over, the pre-processor of \verb!tTPe_1_Add_FaceDown! will prevent any more firings. This is shown in listing \ref{lst:pre_tTPe_Add_FaceDown}, and is done by simply counting how many cards have been dealt in the variable \verb!global_info.CARDS.DEALT!. The secondary condition in the if statement is used to control the amount of firings during the initial phase.
\lstinputlisting[style=matlabcode,caption=pre\_tTPe\_Add\_FaceDown.m lines 5-11,label=lst:pre_tTPe_Add_FaceDown,firstline=5,lastline=11]{\GPenSIM/pre_tTPe_Add_FaceDown.m}

Instead, the \verb!tTPe_1_Add_FaceUp! transition will have potential to fire, given that all of its conditions in the pre-processor is fulfilled. Parts of the code for the pre-processor can be found in listing \ref{lst:pre_tTPe_Add_FaceUp}, whilst the whole file is found in \ref{app:pre_tTPe_Add_FaceUp}. The main job of the pre-processor is to check whether the game is still in the initial phase, and if so, how many cards have been added to \verb!pTP_1_FaceDown_Pile!. While the game is in the initial phase, there are no checks on the the suit or rank of the cards being added, but once it enters the normal phase, the pre-processor will rely on the \verb!checkCommand_Move! function to check the validity against the actual Solitaire rules. More information about the \verb!checkCommand_Move! function is found in chapter \ref{sec:3_move_command}. 
\lstinputlisting[style=matlabcode,caption=pre\_tTPe\_Add\_FaceUp.m lines 7-31,label=lst:pre_tTPe_Add_FaceUp,firstline=7,lastline=31]{\GPenSIM/pre_tTPe_Add_FaceUp.m}

Both the \verb!tTPe_1_Add_FaceDown! and \verb!tTPe_1_Add_FaceUp! also have post-processors which will increment the variable \verb!global_info.CARDS_DEALT!. The post-processor for \verb!tTPe_1_Add_FaceUp! also decrements the variable \\\verb!global_info.TP_Move_Multiple_Count! which is used when multiple cards are to be moved from the pile. Listing \ref{lst:post_tTPe_Add_FaceUp} shows how the variable is decremented, and once the last card has been received, the \verb!playerAction! resource will be released. Full code for the post-processor can be found in \ref{app:post_tTPe_Add_FaceUp}. More details on moving multiple cards will follow in the next paragraphs.
\lstinputlisting[style=matlabcode,caption=post\_tTPe\_Add\_FaceUp.m lines 5-12,label=lst:post_tTPe_Add_FaceUp,firstline=5,lastline=12]{\GPenSIM/post_tTPe_Add_FaceUp.m}

The module encompasses two external inputs, there first of which is \verb!tTPe_1_Turn!. As can be seen in figure \ref{fig:tableau_pile}, the transition is only enabled if there is at least one token in \verb!pTP_1_FaceDown_Pile! and no tokens in \verb!pTP_1_FaceUp_Pile!. The transitions pre-processor will check that the command in \verb!pMC_TP_Turn! is meant for this particular pile. This is done through extracting the unique identifier using the function \verb!get_tableau_from_transname!. \newline

The next external input is \verb!tTPe_1_Move!, which works similarly to the movement inputs of \ac{dp} and \ac{fp}, but with one big difference; it supports moving multiple cards at a time. This is achieved in conjunction with \verb!tTPi_1_Move_Multiple! using two global variables shown in listing \ref{lst:pre_tTPe_Move}. Note that it is only possible to move multiple cards to other \ac{tp}.
\lstinputlisting[style=matlabcode,caption=pre\_tTPe\_Move.m lines 11-19,label=lst:pre_tTPe_Move,firstline=11,lastline=19]{\GPenSIM/pre_tTPe_Move.m}

The same functionality could be achieved using only one variable, however by using two we make sure that the \verb!playerAction! resource remains taken until all the cards have reached their destination. When \verb!tTPi_1_Move_Multiple! fire it will take the token in \verb!pTP_1_Move!, and return two new ones, essentially duplicating the token. By doing this one time less than the amount of cards to be moved, we end up with the desired number of tokens in \verb!pTP_1_Move!. Listing \ref{lst:pre_tTPi_Move_Multiple} shows the pre-processor of \verb!tTPi_1_Move_Multiple!, and listing \ref{lst:COMMON_POST_2} shows how \verb!global_info.TP_Move_Multi_Gen_Tokens! is decremented in the \verb!COMMON_POST! file.
\lstinputlisting[style=matlabcode,caption=pre\_tTPi\_Move\_Multiple.m lines 6-13,label=lst:pre_tTPi_Move_Multiple,firstline=6,lastline=13]{\GPenSIM/pre_tTPi_Move_Multiple.m}

\lstinputlisting[style=matlabcode,caption=COMMON\_POST.m lines 28-34,label=lst:COMMON_POST_2,firstline=28,lastline=34]{\GPenSIM/COMMON_POST.m}

The only external output is \verb!tTPe_1_Out!, which will only fire once enough tokens are generated by \verb!tTPi_1_Move_Multiple!. In order ensure that the correct card is moved, the pre-processor will fetch the \textbf{n}-th latest arrived card. Where \textbf{n} is the number of tokens in \verb!pTP_1_Move!. This is repeated for every token in \verb!pTP_1_Move!. By doing this, correctness is preserved by always moving the highest ranking card first. Listing \ref{lst:pre_tTPe_Out} shows the main logic of the pre-processor, the whole file is found in at \ref{app:pre_tTPe_Out}.
\lstinputlisting[style=matlabcode,caption=pre\_tTPe\_Out.m lines 6-19,label=lst:pre_tTPe_Out,firstline=6,lastline=19]{\GPenSIM/pre_tTPe_Out.m}

\begin{table}
	\caption{Places and transitions used in Tableau Pile - 1}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pTP\_1\_FaceDown\_Pile    &  Holds the face-down cards. These are not visible to the player.\\ \hline
		2 & pTP\_1\_FaceUp\_Pile      &  Holds the face-up cards. All cards are visible to the player.\\ \hline
		3 & pTP\_1\_Move              &  Buffer for move-commands\\ \hline
		4 & tTPe\_1\_Add\_FaceDown   &  External input for adding cards to the face-up pile.  \\ \hline
		5 & tTPe\_1\_Add\_FaceUp     &  External input for adding cards to the face-down pile during the initial phase.  \\ \hline
		6 & tTPe\_1\_Move            &  External input for the move-command.  \\ \hline
		7 & tTPe\_1\_Out             &  External output  \\ \hline
		8 & tTPe\_1\_Turn            &  External input for the turn-command.  \\ \hline
		9 & tTPi\_1\_Move\_Multiple  &  Internal transition which duplicates the move-command when moving multiple cards.  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Player Module}
The Player module is a set of 20 transitions, tightly knit with the \ac{gui} and the Module Connector. This module differs from the \ac{dp}, \ac{fp} and \ac{tp} modules in that the arcs to the Module Connector are done in the Player module rather than in the Module Connector. By doing this, it is possible to toggle this module on/off in the variable \verb!global_info.GUI_ENABLED!.
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/playerModule}
		\caption{Player module}
		\label{fig:player_module}
	\end{center}
\end{figure}\\
An important aspect of the Player module is the acquisition of the \verb!playerAction! resource in the pre-processor file of every transition. By doing this, the atomicity of each action is preserved, as it's not possible to start a new action before the previous one finishes executing. Resources are discussed in more detail in chapter \ref{sec:3_Resources}.\\

In order to make the buttons of the GUI be responsive, it was necessary to introduce the \verb!pause! command in one of the pre-processors. For this, the \verb!tPe_DP_Turn_pre! pre-processor was chosen. It's a bit unclear what exactly happens when the \verb!pause! command executes, but I suspect Matlab has a seperate event queue for all GUI elements. This queue is likely checked every time the main program execution is halted with \verb!pause!. There might be a more elegant way of doing this, but none was located. Having the \verb!pause! command execute in the pre-processor executes might not be well-suited for real-time simulations as it might introduce bias in the timings. In this project however, this solution worked very well, with no problems or unresponsiveness at all.
\lstinputlisting[style=matlabcode,caption=tPe\_DP\_Turn\_pre.m,label=lst:tPe_DP_Turn_pre]{\GPenSIM/tPe_DP_Turn_pre.m}

As can be seen in listing \ref{lst:tPe_DP_Turn_pre}, to check if a button is pressed is actually a matter of checking whether the global variable corresponding to that button is set. In the listing above, it is accomplished by checking if \verb!global_info.DP_Turn_Btn! is set, and if so set it back to false. A consequence of doing this, is that it's possible to queue up actions, for example by hitting the \ac{dp} Turn-button when the game is in process of moving cards from one pile to another. \\

When issuing a new move command, its destination and possibly amount of cards to be moved is fetched directly from the GUI elements. 
\begin{table}
	\caption{Transitions used in Player}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & tPe\_DP\_Move            &  Sends a move command to the DP module.  \\ \hline
		2 & tPe\_DP\_Turn            &  Sends a turn command to the DP module.  \\ \hline
		3 & tPe\_FP\_Clubs\_Move     &  Sends a move command to the FP Clubs module.  \\ \hline
		4 & tPe\_FP\_Diamonds\_Move  &  Sends a move command to the FP Diamonds module.  \\ \hline
		5 & tPe\_FP\_Hearts\_Move    &  Sends a move command to the FP Hearts module.  \\ \hline
		6 & tPe\_FP\_Spades\_Move    &  Sends a move command to the FP Spades module.  \\ \hline
		7 & tPe\_TP\_1\_Move         &  Sends a move command to the TP 1 module.  \\ \hline
		8 & tPe\_TP\_1\_Turn         &  Sends a turn command to the TP 1 module.  \\ \hline
		9 & tPe\_TP\_2\_Move         &  Sends a move command to the TP 2 module.  \\ \hline
		10 & tPe\_TP\_2\_Turn        &  Sends a turn command to the TP 2 module.  \\ \hline
		11 & tPe\_TP\_3\_Move        &  Sends a move command to the TP 3 module.  \\ \hline
		12 & tPe\_TP\_3\_Turn        &  Sends a turn command to the TP 3 module.  \\ \hline
		13 & tPe\_TP\_4\_Move        &  Sends a move command to the TP 4 module.  \\ \hline
		14 & tPe\_TP\_4\_Turn        &  Sends a turn command to the TP 4 module.  \\ \hline
		15 & tPe\_TP\_5\_Move        &  Sends a move command to the TP 5 module.  \\ \hline
		16 & tPe\_TP\_5\_Turn        &  Sends a turn command to the TP 5 module.  \\ \hline
		17 & tPe\_TP\_6\_Move        &  Sends a move command to the TP 6 module.  \\ \hline
		18 & tPe\_TP\_6\_Turn        &  Sends a turn command to the TP 6 module.  \\ \hline
		19 & tPe\_TP\_7\_Move        &  Sends a move command to the TP 7 module.  \\ \hline
		20 & tPe\_TP\_7\_Turn        &  Sends a turn command to the TP 7 module.  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Player Bot Module}
\begin{table}
	\caption{Places and transitions used in Player Bot}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pPB\_Cmd          &  \\ \hline
		2 & tPBe\_DP\_Move    &  \\ \hline
		3 & tPBe\_DP\_Turn    &  \\ \hline
		4 & tPBe\_FP\_Move    &  \\ \hline
		5 & tPBe\_TP\_Move    &  \\ \hline
		6 & tPBe\_TP\_Turn    &  \\ \hline
		7 & tPBi\_Gen         &  \\ \hline
		8 & tPBi\_Siphon      &  \\ \hline
	\end{tabular}
\end{table}
*tPBi\_Gen\_Stop is deleted. But code is still there. Make comment on why this is removed*
\clearpage
\subsection{Module Connector}

\begin{table}
	\caption{Places and transitions used in Module Connector}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pMC\_DP\_Move             &  \\ \hline
		2 & pMC\_DP\_Turn             &  \\ \hline
		3 & pMC\_FP\_Move             &  \\ \hline
		4 & pMC\_Out\_Buffer          &  \\ \hline
		5 & pMC\_TP\_Move             &  \\ \hline
		6 & pMC\_TP\_Turn             &  \\ \hline
		7 & tMC\_DP\_Move\_Siphon     &  \\ \hline
		8 & tMC\_FP\_Move\_Siphon     &  \\ \hline
		9 & tMC\_Out\_Buffer\_Siphon  &  \\ \hline
		10 & tMC\_TP\_Move\_Siphon     &  \\ \hline
		11 & tMC\_TP\_Turn\_Siphon     &  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\section{Implementation}
\label{sec:3_implementation}
\subsection{\ac{gui}}
\label{sec:3_gui}
\clearpage
\subsection{Algorithms}
\subsubsection{Atomicity}
\clearpage
\subsection{Commands}
\subsubsection{Move Command}~\\~\\
\label{sec:3_move_command}
The move command is contains four parts; the command, destination, source and amount. Each part is concatenated together, with colon as a separator. An example of a move command would be: \textit{Move:\ac{tp}1:\ac{tp}5:3}, which means \textit{Move 3 cards from \ac{tp}1 to \ac{tp}5}. If amount is not given, it will assume one card to be moved.
\newline

In order to make sure that only validity of the move-commands, the function \verb!checkCommand_Move! has been developed. It is used both for validation before sending a command, and validation after receiving a command. The function takes the input parameters; \verb!command!, \verb!destination!, \verb!source!, and \verb!handle_err!. 
\newline

The input parameter \verb!command! contains the actual command, \verb!destination! contains the unique identifiers of the \ac{fp} or \ac{tp} modules. Valid input for \verb!destination! would be \textit{C, D, H, S, 1, 2, 3, 4, 5, 6 or 7}, and is used to ensure that the command is received by the destined module. Parameter \verb!source! is only used when sending a command, and contains the actual name of the transition which issued the game. This is mainly used to set the variable \verb!global_info.last_command_source! which will be the name of the transition holding the \verb!playerAction! resource. Resources are discussed in more detail in chapter \ref{sec:3_Resources}. Lastly, the parameter \verb!handle_err! holds the GUI-component where error mesasges will be written. Full code for the function can be found in the appendix, at chapter \ref{app:checkCommand_Move}.
\\

Figure \ref{fig:checkCommand_Move} shows a flowchart of the logic in the function.
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/checkCommand_Move}
		\caption{Flowchart - checkCommand\_Move}
		\label{fig:checkCommand_Move}
	\end{center}
\end{figure}
\clearpage
\subsection{Initial Dealing}
\subsection{Resources}
\label{sec:3_Resources}
\subsection{Moving Multiple Cards}
\subsection{Scoring}
\subsection{Possible improvments}
A major drawback of the siphon \verb!tMC_Out_Buffer_Siphon! is that if it fires, the card will actually be removed from the game, and the game becomes unsolvable. This transition will fire if the move-command of the token has an invalid destination. Due to how the Player and Player Bot modules are set up, this will never happen as they will check the validity of the move command before actually issuing the command. Still, I think it would be an improvement add an additional transition to the Draw Pile module which would accept cards from \verb!tMC_Out_Buffer_Siphon!, instead of totally discarding them.
\newline

Another improvement would be to re-factor the code base by moving more of the validity check of the commands from the Player and Player Bot modules to the destination transitions. The Player Bot modules uses roughly 200 lines of code to always issue valid commands, I think this could be drastically reduced. By doing this it would be easier to create additional modules which could interface with the game, for example a hardware-based module.
\newline

It might also be a slight improvement to combine the Add-face-up and Add-face-down transitions of the \ac{tp} modules. By doing this, it would remove the need for the Add-face-down's pre-processor to execute once the initial phase is over. However, doing so for every Tableau Pile would require 7 more transitions and 14 more places. \\

Lastly, a performance increase might be gained by reducing the number of transitions in the Player module, or at least introducing a new place and transition. This new place would serve as an input to all of the 20 transitions of the Player module, whilst the new transition would serve as an input the new place. By doing this, the number enabled transitions, and pre-processors which would have to be executed would drastically drop.
\clearpage
\subsection{Future work}
dladl
\section{Testing, Analysis and Results}
\subsection{Matlab version}
The project has been developed and tested in versions R2013a and R2017a. Due to using two versions of Matlab it was necessary to only use functionality that is supported in both versions. Examples of this is using \verb!GUIDE! for developing the GUI, and omitting to use the \verb!contains! command.
\label{sec:3_testing_analysis}
\subsection{Algorithms}
\subsubsection{Atomicity}
In order to preventdd
\subsection{Initial Dealing}
\label{sec:3_initial_dealing}
\subsection{Resources}
\subsection{Moving Multiple Cards}

\section{Discussion}



% Keeping this for reference for now %
\begin{thebibliography}{6}

\bibitem{wikiTFIDF} Wikipedia article on Tf-idf. \url{https://en.wikipedia.org/wiki/Tf?idf}
\bibitem{oreilly} Tom White, Hadoop: The Definitive Guide, 2015, \emph{ISBN: 978-1-491-90163-2}
\bibitem{dockerdocs} Docker API Docs, \url{https://docs.docker.com}
\bibitem{dat630slides} Slides from DAT630, Krisztian Balog
\bibitem{dataset} Kaggle. The Enron Email Dataset. \url{https://www.kaggle.com/wcukierski/enron-email-dataset}
\bibitem{coursematerial} Data Intensive Systems Compendium, Tomasz Wiktorski et al.

\end{thebibliography}
\addtocmark{Appendix}
\appendix
\section{Overall design - horizontal view}
\begin{figure}
	% Left, Bottom, Right, Top
	\includegraphics[trim=40 100 100 310,angle=90,scale=1.4]{images/overallViewPdf}
	\caption{The complete model in horizontal view}
	\label{fig:full_vertical}
\end{figure}
\clearpage
\section{Matlab code}	
\subsection{checkCommand\_Move.m}
\label{app:checkCommand_Move}
\lstinputlisting[style=matlabcode]{\GPenSIM/checkCommand_Move.m}

\subsection{COMMON\_POST.m}
\label{app:COMMON_POST}
\lstinputlisting[style=matlabcode]{\GPenSIM/COMMON_POST.m}

\subsection{COMMON\_PRE.m}
\label{app:COMMON_PRE}
\lstinputlisting[style=matlabcode]{\GPenSIM/COMMON_PRE.m}

\subsection{draw\_pile\_pdf.m}
\label{app:draw_pile_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/draw_pile_pdf.m}

\subsection{foundation\_pile\_clubs\_pdf.m}
\label{app:foundation_pile_clubs_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_clubs_pdf.m}

\subsection{foundation\_pile\_diamonds\_pdf.m}
\label{app:foundation_pile_diamonds_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_diamonds_pdf.m}

\subsection{foundation\_pile\_hearts\_pdf.m}
\label{app:foundation_pile_hearts_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_hearts_pdf.m}

\subsection{foundation\_pile\_spades\_pdf.m}
\label{app:foundation_pile_spades_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_spades_pdf.m}

\subsection{get\_handle.m}
\label{app:get_handle}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_handle.m}

\subsection{get\_suit\_from\_transname.m}
\label{app:get_suit_from_transname}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_suit_from_transname.m}

\subsection{get\_tableau\_from\_transname.m}
\label{app:get_tableau_from_transname}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_tableau_from_transname.m}

\subsection{main\_simulation\_file.m}
\label{app:main_simulation_file}
\lstinputlisting[style=matlabcode]{\GPenSIM/main_simulation_file.m}

\subsection{module\_connector\_pdf.m}
\label{app:module_connector_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/module_connector_pdf.m}

\subsection{player\_bot\_pdf.m}
\label{app:player_bot_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_bot_pdf.m}

\subsection{player\_GUI.m}
\label{app:player_GUI}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_GUI.m}

\subsection{player\_pdf.m}
\label{app:player_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_pdf.m}

\subsection{player\_update\_GUI.m}
\label{app:player_update_GUI}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_update_GUI.m}

\subsection{post\_tTPe\_Add\_FaceUp.m}
\label{app:post_tTPe_Add_FaceUp}
\lstinputlisting[style=matlabcode]{\GPenSIM/post_tTPe_Add_FaceUp.m}

\subsection{pre\_tFPe\_Add.m}
\label{app:pre_tFPe_Add}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Add.m}

\subsection{pre\_tFPe\_Move.m}
\label{app:pre_tFPe_Move}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Move.m}

\subsection{pre\_tFPe\_Out.m}
\label{app:pre_tFPe_Out}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Out.m}

\subsection{pre\_tPe\_FP\_Move.m}
\label{app:pre_tPe_FP_Move}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_FP_Move.m}

\subsection{pre\_tPe\_TP\_Move.m}
\label{app:pre_tPe_TP_Move}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_TP_Move.m}

\subsection{pre\_tPe\_TP\_Turn.m}
\label{app:pre_tPe_TP_Turn}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_TP_Turn.m}

\subsection{pre\_tTPe\_Add\_FaceDown.m}
\label{app:pre_tTPe_Add_FaceDown}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Add_FaceDown.m}

\subsection{pre\_tTPe\_Add\_FaceUp.m}
\label{app:pre_tTPe_Add_FaceUp}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Add_FaceUp.m}

\subsection{pre\_tTPe\_Move.m}
\label{app:pre_tTPe_Move}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Move.m}

\subsection{pre\_tTPe\_Out.m}
\label{app:pre_tTPe_Out}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Out.m}

\subsection{pre\_tTPe\_Turn.m}
\label{app:pre_tTPe_Turn}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Turn.m}

\subsection{pre\_tTPi\_Move\_Multiple.m}
\label{app:pre_tTPi_Move_Multiple}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPi_Move_Multiple.m}

\subsection{set\_handle.m}
\label{app:set_handle}
\lstinputlisting[style=matlabcode]{\GPenSIM/set_handle.m}

\subsection{splitCommand.m}
\label{app:splitCommand}
\lstinputlisting[style=matlabcode]{\GPenSIM/splitCommand.m}

\subsection{tableau\_pile\_1\_pdf.m}
\label{app:tableau_pile_1_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_1_pdf.m}

\subsection{tableau\_pile\_2\_pdf.m}
\label{app:tableau_pile_2_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_2_pdf.m}

\subsection{tableau\_pile\_3\_pdf.m}
\label{app:tableau_pile_3_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_3_pdf.m}

\subsection{tableau\_pile\_4\_pdf.m}
\label{app:tableau_pile_4_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_4_pdf.m}

\subsection{tableau\_pile\_5\_pdf.m}
\label{app:tableau_pile_5_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_5_pdf.m}

\subsection{tableau\_pile\_6\_pdf.m}
\label{app:tableau_pile_6_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_6_pdf.m}

\subsection{tableau\_pile\_7\_pdf.m}
\label{app:tableau_pile_7_pdf}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_7_pdf.m}

\subsection{tDPe\_Move\_pre.m}
\label{app:tDPe_Move_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPe_Move_pre.m}

\subsection{tDPe\_Out\_pre.m}
\label{app:tDPe_Out_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPe_Out_pre.m}

\subsection{tDPi\_Dealer\_pre.m}
\label{app:tDPi_Dealer_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Dealer_pre.m}

\subsection{tDPi\_Enable\_FP\_Trans\_post.m}
\label{app:tDPi_Enable_FP_Trans_post}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Enable_FP_Trans_post.m}

\subsection{tDPi\_Flip\_Pile\_post.m}
\label{app:tDPi_Flip_Pile_post}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Flip_Pile_post.m}

\subsection{tDPi\_Flip\_Pile\_pre.m}
\label{app:tDPi_Flip_Pile_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Flip_Pile_pre.m}

\subsection{tDPi\_Move\_Init\_pre.m}
\label{app:tDPi_Move_Init_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Move_Init_pre.m}

\subsection{tDPi\_Turn\_post.m}
\label{app:tDPi_Turn_post}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Turn_post.m}

\subsection{tDPi\_Turn\_pre.m}
\label{app:tDPi_Turn_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Turn_pre.m}

\subsection{tMC\_DP\_Move\_Siphon\_pre.m}
\label{app:tMC_DP_Move_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_DP_Move_Siphon_pre.m}

\subsection{tMC\_FP\_Move\_Siphon\_pre.m}
\label{app:tMC_FP_Move_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_FP_Move_Siphon_pre.m}

\subsection{tMC\_Out\_Buffer\_Siphon\_pre.m}
\label{app:tMC_Out_Buffer_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_Out_Buffer_Siphon_pre.m}

\subsection{tMC\_TP\_Move\_Siphon\_pre.m}
\label{app:tMC_TP_Move_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_TP_Move_Siphon_pre.m}

\subsection{tMC\_TP\_Turn\_Siphon\_pre.m}
\label{app:tMC_TP_Turn_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_TP_Turn_Siphon_pre.m}

\subsection{tPBe\_DP\_Move\_pre.m}
\label{app:tPBe_DP_Move_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_DP_Move_pre.m}

\subsection{tPBe\_DP\_Turn\_pre.m}
\label{app:tPBe_DP_Turn_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_DP_Turn_pre.m}

\subsection{tPBe\_FP\_Move\_pre.m}
\label{app:tPBe_FP_Move_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_FP_Move_pre.m}

\subsection{tPBe\_TP\_Move\_pre.m}
\label{app:tPBe_TP_Move_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_TP_Move_pre.m}

\subsection{tPBe\_TP\_Turn\_pre.m}
\label{app:tPBe_TP_Turn_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_TP_Turn_pre.m}

\subsection{tPBi\_Gen\_pre.m}
\label{app:tPBi_Gen_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Gen_pre.m}

\subsection{tPBi\_Gen\_Stop\_pre.m}
\label{app:tPBi_Gen_Stop_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Gen_Stop_pre.m}

\subsection{tPBi\_Siphon\_pre.m}
\label{app:tPBi_Siphon_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Siphon_pre.m}

\subsection{tPe\_DP\_Move\_pre.m}
\label{app:tPe_DP_Move_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPe_DP_Move_pre.m}

\subsection{tPe\_DP\_Turn\_pre.m}
\label{app:tPe_DP_Turn_pre}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPe_DP_Turn_pre.m}

\end{document}
