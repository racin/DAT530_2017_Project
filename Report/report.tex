
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{url}
\usepackage{xcolor}
\usepackage{acro}


\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\usepackage{nameref}
\acsetup{first-style=short}

% Abbreviations
\DeclareAcronym{dp}{short = DP, long = Draw Pile Module, class = abbrev}
\DeclareAcronym{fp}{short = FP, long = Foundation Pile Module, class = abbrev}
\DeclareAcronym{tp}{short = TP, long = Tableau Pile Module, class = abbrev}
\DeclareAcronym{p}{short = P, long = Player Module, class = abbrev}
\DeclareAcronym{pb}{short = PB, long = Player Bot Module, class = abbrev}
\DeclareAcronym{fifo}{short = FIFO, long = First In First Out (Queue), class = abbrev}
\DeclareAcronym{lifo}{short = LIFO, long = Last In First Out (Stack), class = abbrev}
\DeclareAcronym{gui}{short = GUI, long = Graphical User Interface, class = abbrev}

% Nomenclature
\DeclareAcronym{card}{short = card, long = (In the Petri Net context) A token with a color which represents a card in the deck., class = nomencl}
\DeclareAcronym{command}{short = command, long = A token with a color which represents a turn or movement command., class = nomencl}

\newcommand{\GPenSIM}{../GPenSIM}
\definecolor{matlabcomment}{RGB}{34,139,34}
\definecolor{matlabstring}{RGB}{160,32,240}
\definecolor{matlabkeyword}{RGB}{0,0,255}
\lstdefinestyle{matlabcode}{
	language=Matlab,
	frame=single,
	%caption=\lstname,
	stringstyle=\color{matlabstring},
	keywordstyle=\color{matlabkeyword},
	commentstyle=\color{matlabcomment},
	basicstyle=\fontsize{6}{7}\selectfont,%\tiny
	breaklines=true,
	numbers=left
}


\begin{document}
\mainmatter  % start of an individual contribution
% first the title is needed
\title{DAT530\\Discrete Simulation and Performance Analysis\\Final Project\\Solitaire game strategy}
% a short form should be given in case it is too long for the running head
\titlerunning{DAT530 - Final Project}
\author{Racin W. Nygaard}
\authorrunning{DAT530 - Final Project - Solitaire game strategy}
% (feature abused for this document to repeat the title also on left hand pages)
\institute{Universitetet i Stavanger}

\toctitle{Abstract}
\tocauthor{ }
\maketitle
	


\begin{abstract}
This project is such and such... +++

\end{abstract}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\tableofcontents
\listoffigures
\listoftables
\printacronyms[name=Abbreviations,include-classes=abbrev]
\printacronyms[name=Nomenclature,include-classes=nomencl]
\section{Introduction}
This project aims to study the popular card game, Solitaire[Site]. Solitaire is bundled with most Windows[Site] installations, as well as being available for free on several sources. It is also easy to play the game with a physical card deck. A detailed explanation of the games rules can be found in the next chapter, Solitaire Rules[REF]
\newline
Since the game utilizes all 52 cards of the deck, the number of possible initial game states is 52!, which is a very high number. A large number of these inital game states can be merged, as they offer no difference in the difficulty to solve. Some of these initial states are unsolvable, but even given a solvable game state, one often find oneself in an unsolvable game state, due to certain actions in the game are non-reversible,. There has been attempts to find the distribution of solvable and unsolvable initial game states [ref]. This is roughly 75 percent are solvable, however the study also shows that only 35 percent of the games are won by an experienced player.
\newline
This project contains a complete model of the game, a GUI to play the game, and a basic bot to simulate user actions. 

\subsection{Solitaire Rules}


Finite State Machine ?


\section{Method and Design}
\label{sec:2_method_and_design}
\subsection{Naming Policy}
\subsection{File structure}
\label{sec:2_file_structure}
To reduce the number of files, most of the pre- and post-processor files of the \ac{fp} and \ac{tp} modules have been combined in one single file. An example of this can be shown in listing \ref{lst:COMMON_PRE}, which shows parts of \verb!COMMON_PRE!
\lstinputlisting[style=matlabcode,caption=COMMON\_PRE.m lines 1-5,label=lst:COMMON_PRE,lastline=5]{\GPenSIM/COMMON_PRE.m}

By doing this it is possible to reduce the number of files required without overloading the \verb!COMMON_PRE! and \verb!COMMON_POST! files. It also makes it much easier to work and maintain the code as the logic is only located in one place, as opposed to four or seven places if each transition had their own file.
\newline

With this approach it is no longer possible to hard-code the names of the related transitions and places, so two additional functions; \verb!get_tableau_from_transname! and \verb!get_suit_from_transname! were developed. These functions take the name of the transition as input, and then return the unique identifier for which module it belongs to. The actual code is pretty simple, and parts of \verb!get_suit_from_transname! is shown in listing \ref{lst:get_suit_from_transname}. The reasoning behind not using the Matlab command \verb!contains! is simply that it is not supported in older versions.
\lstinputlisting[style=matlabcode,caption=get\_suit\_from\_transname.m lines 7-17,label=lst:get_suit_from_transname,firstline=7,lastline=17]{\GPenSIM/get_suit_from_transname.m}
\clearpage
\subsection{Overall Design}

\begin{figure}
	\label{fig:full_horizontal}
	\begin{center} % Left, Bottom, Right, Top
		\includegraphics[trim=250 260 230 330,scale=1.1]{images/overallViewPdf}
	\end{center}
	\caption{The complete model - Without the internal components of the modules.}
\end{figure}


The model developed is pretty large, and contains 94 transition and 42 places. It is developed using the modualar approach, and encompasses 6 different modules. Some of the modules are duplicated, with the only difference being the names of the transitions and places.
\newline

\subsection{Draw Pile Module}
\label{sec:draw_pile}
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/drawPile}
		\caption{Draw Pile Module}
		\label{fig:draw_pile}
	\end{center}
\end{figure}
The Draw Pile module is depicted in figure \ref{fig:draw_pile}, and has several key responsibilities, once of which is to do the initial dealing of cards. In order to preserve the correctness of the gameplay, external input is not allowed during this phase. When first running the model, all the initial tokens of \verb!pDP_Dealer! will be sent to \verb!tDPi_Dealer!. This transition will give each token a color which represents a \ac{card} in the deck. Possible colors are initially stored in the cell \verb!global_info.DECK!. If \verb!global_info.RANDOM_DECK! is set, a random permutation of the colors will be given to the tokens. By having \verb!global_info.RANDOM_DECK! set to false, it is possible to run analytics which require that the cards are dealt equally each time.
\newline

After all tokens are given a color, \verb!tDPi_Turn! will be enabled. This transition will move cards from the pile which represents face-down cards, \verb!pDP_Draw_FaceDown_Pile! to the one representing face-up cards, \verb!pDP_Draw_FaceUp_Pile!. This transition will fire as many times as the length of \verb!global_info.INITIAL_DEAL_MOVE!, which is 28 in a normal game. This is not something that would be done if the game where played with physical cards, as they would just be dealt without turning them. In this model however, this is required so that existing logic could be re-used.
\newline

Concurrently to the firing of \verb!tDPi_Turn!, the transition \verb!tDPi_Move_Init! will fire an equal amount of times. The transition will give each of the tokens in \verb!pDP_Move_Init! a color which represents to which tableau pile the \ac{card} should be moved to. The color given to each token is augmented by the cell, \verb!global_info.INITIAL_DEAL_MOVE!. An example of a color given is \emph{Move:\ac{tp}1:\ac{dp}} which means; \textit{Moving a card from source DP to destination \ac{tp}1}. Every time a \ac{card} reaches its destined tableau pile, the variable \verb!global_info.CARDS_DEALT! will be incremented by one in \verb!COMMON_POST!. Once it becomes equal to the length of \verb!global_info.INITIAL_DEAL_MOVE!, the initial dealing phase is over, and the normal phase starts.
\newline

During the normal phase, external input is allowed. The first input of the Draw Pile Module is \verb!tDPe_Move!. This transition has an pre-processor file, which makes it only fire if there are tokens in \verb!pDP_Draw_FaceUp_Pile!. Additionally, the Player and Player Bot modules ensures that the enabling token has color on the format \textit{Move:(destination):\ac{dp}}.
\lstinputlisting[style=matlabcode,caption=tDPe\_Move\_pre.m,label=lst:tDPe_Move_pre]{\GPenSIM/tDPe_Move_pre.m}

The second input, \verb!tDPe_Turn! is used to used to simply move cards from the face-down pile to the face-up pile during the normal phase. An interesting thing about this is that once all the cards are in the face-up pile, the next time one attempts to turn a \ac{card}, all cards should be moved back to the face-down pile in \ac{lifo} style, just as they would if you simply flip the deck of cards around in real-life. 
\newline
This is accomplished by the transitions \verb!tDPi_Flip_Pile! and \verb!tDPi_Enable_DP_Trans!. The \verb!tDPi_Enable_FP_Trans! is actually an siphon, and becomes enabled once \verb!pDP_Draw_FaceDown_Pile! is empty, and there is an active turn action on-going so that \verb!pDP_Turn! has at least one token. The transition has one post-processor file, shown in listing \ref{lst:tDPi_Enable_FP_Trans_post}. Given that there are actually any tokens left in \verb!pDP_Draw_FaceUp_Pile! it will set the global flag, \verb!global_info.DP_Flip_Pile_Running! to \verb!true!, if there are no tokens in the face-up pile, it will simply release the \verb!playerAction! resource. The use of resources is discussed further in chapter \ref{sec:3_Resources}. The reason for not having an arc directly from the face-up pile is due to this transition being a siphon, so the \ac{card} would be removed from the game if it fired.
\lstinputlisting[style=matlabcode,caption=tDPi\_Enable\_FP\_Trans\_post.m,label=lst:tDPi_Enable_FP_Trans_post]{\GPenSIM/tDPi_Enable_FP_Trans_post.m}
Once \verb!global_info.DP_Flip_Pile_Running! is set to \verb!true! and there are tokens in \verb!pDP_Draw_FaceUp_Pile!, the transition \verb!tDPi_Flip_Pile! will start firing. The pre-processor file is listed in \ref{lst:tDPi_Flip_Pile_pre}, and will keep selecting the latest arrived \ac{card} from \verb!pDP_Draw_FaceUp_Pile! and fire. In the post-processor file, listed in \ref{lst:tDPi_Flip_Pile_post}, it will check for the length of the face-up pile, once it becomes empty it will set the flag \verb!global_info.DP_Flip_Pile_Running! to \verb!false!, and the cards have been successfully turned around.
\lstinputlisting[style=matlabcode,caption=tDPi\_Flip\_Pile\_pre.m,label=lst:tDPi_Flip_Pile_pre]{\GPenSIM/tDPi_Flip_Pile_pre.m}
\lstinputlisting[style=matlabcode,caption=tDPi\_Flip\_Pile\_post.m,label=lst:tDPi_Flip_Pile_post]{\GPenSIM/tDPi_Flip_Pile_post.m}

Lastly, there is the \verb!tDPe_Out! transition. This is the only external output of the module. When enabled, its pre-processor will take the lastest card arrived at \verb!pDP_Draw_FaceUp_Pile!, but the earliest command arrived at \verb!pDP_Move_Out! when firing. By taking the earliest command arrived in a \ac{fifo} manner, we ensure that the inital dealing will be correct. If we were to take the latest command, we would have to add additional logic such as alternating firing to make certain the ordering of cards would be correct. The code is shown in lising \ref{lst:tDPe_Out_pre}
\lstinputlisting[style=matlabcode,caption=tDPe\_Out\_pre.m,label=lst:tDPe_Out_pre]{\GPenSIM/tDPe_Out_pre.m}
Interestingly, moving cards out of the \verb!tDPe_Out! transition is a non-reversible action as the module has no external input. So by doing this one could potentially put the game in an unsolvable state.
\begin{table}
	\caption{Places and transitions used in Draw Pile}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1  & pDP\_Dealer               & Holds the initial tokens which will become cards. \\ \hline
		2  & pDP\_Draw\_FaceDown\_Pile & Holds the face-down cards. These are not visible to the player. \\ \hline
		3  & pDP\_Draw\_FaceUp\_Pile   & Holde the face-up cards. Only the top card is visible to the player. \\ \hline
		4  & pDP\_Move\_Init           & Holds initial tokens used for generating move-commands. \\ \hline
		5  & pDP\_Move\_Out            & Buffer for move-commands.  \\ \hline
		6  & pDP\_Turn                 & Buffer for turn-commands. \\ \hline
		7  & tDPe\_Move               &   External input for the move-\ac{command} \\ \hline
		8  & tDPe\_Out                &   External output \\ \hline
		9  & tDPe\_Turn               &   External input for the turn-\ac{command} \\ \hline
		10  & tDPi\_Dealer             &   Gives every token a color to represent a card in the deck. \\ \hline
		11  & tDPi\_Enable\_FP\_Trans  &   Used to facilitate the flipping of the face-up pile. \\ \hline
		12  & tDPi\_Flip\_Pile         &   Moves cards from face-up pile to face-down pile in a \ac{lifo} manner. \\ \hline
		13  & tDPi\_Move\_Init         &   Generates initial move-commands to facilitate initial dealing of the cards. \\ \hline
		14  & tDPi\_Turn               &   Moves a card from the face-down pile to the face-up pile. \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Foundation Pile Module}
The Foundation Pile module is depicted figure \ref{fig:foundation_pile}. It is duplicated four times, once for every suit, clubs, diamonds, hearts, and spades. The only difference between these modules is the names of their respective transitions and names, so the description given for clubs will count for the other duplicates as well. All the pre- and post-processor files are shared between all the suits.
\newline
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/foundationPile}
		\caption{Foundation Pile Module}
		\label{fig:foundation_pile}
	\end{center}
\end{figure}

This module is inactive during the initial phase, and only becomes interact-able once the normal phase starts. It has two external inputs, the first of which is \verb!tFPe_Clubs_Add!. This transition has a shared pre-processor file, \verb!pre_tFPe_Add!. Listing \ref{lst:pre_tFPe_Add} shows parts of the logic, the full file can be found in \ref{app:pre_tFPe_Add.m}. The pre-processor fetches the token arrived earliest at \verb!pMC_Out_Buffer!. This is an important step, but is not strictly required because of the limitations the resource \verb!playerAction! enforces on the transitions of the Player and Player Bot modules. Still, it makes sense to fetch the earliest token in \ac{fifo} style to make sure that the first moved card reaches its destination first. 
\newline

Given that the colors of the token have the correct length, the \verb!get_suit_from_transname! function will be run to determine which \ac{fp} the executing transition belongs to. More information about this step can be found in \ref{sec:2_file_structure}. Lastly, the \verb!checkCommand_Move! function is ran to determine the validity of the command in the context of this particular transition. The \verb!checkCommand_Move! function is quite involved, and is discussed in detail in chapter \ref{sec:3_move_command}.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Add.m lines 5-17,label=lst:pre_tFPe_Add,firstline=5,lastline=17]{\GPenSIM/pre_tFPe_Add.m}

The second external input is \verb!tFPe_Clubs_Move!. Its used for moving cards to other modules, and works similarly to how movement in handle in the Draw Pile, with the additional caveat that all four Foundation Piles becomes enabled at the time from \verb!pMC_FP_Move!. Due to this its necessary to introduce additional logic to ensure that the issued move-command from the Player or Player Bot modules are meant for this particular module. As with the other modules, the actual validity of the move-command are handles by the \ac{p} and \ac{pb} modules.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Move.m lines 4-10,label=lst:pre_tFPe_Move,firstline=4,lastline=10]{\GPenSIM/pre_tFPe_Move.m}

The only external output of the {fp} is \verb!tFPe_Clubs_Out!. It works similarly to the output of the Draw Pile, where the pre-processor takes the latest arrived card \verb!pFP_Clubs_Pile! and the earliest arrived command from \verb!pFP_Clubs_Move!. This ensures that the first issued command will be processed first, should there be more than one. The only time there would be more than one command executing concurrently is if neither the Player or the Player Bot modules where enabled, and the command was issued from another module which did not use the \verb!playerAction! resource. Listing \ref{lst:pre_tFPe_Out} shows parts of the code.
\lstinputlisting[style=matlabcode,caption=pre\_tFPe\_Out.m lines 4-10,label=lst:pre_tFPe_Out,firstline=4,lastline=10]{\GPenSIM/pre_tFPe_Out.m}


Another interesting fact about the Foundation Pile modules is the place \verb!pFP_Clubs_Pile!. Once this place is filled with 13 tokens for all the suits, the game is won, and the simulation ends. There is no check done on the actual color or order of the tokens, as that is done when adding them by the pre-processor of \verb!tFPe_Clubs_Add!. The win condition can be found in \verb!COMMON_POST!. Parts of the code is shown in listing \ref{lst:COMMON_POST}.
\lstinputlisting[style=matlabcode,caption=COMMON\_POST.m lines 31-40,label=lst:COMMON_POST,firstline=31,lastline=40]{\GPenSIM/COMMON_POST.m}
\begin{table}
	\caption{Places and transitions used in Foundation Pile - Clubs}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1  & pFP\_Clubs\_Move        &  Buffer for move-\ac{command}s \\ \hline
		2  & pFP\_Clubs\_Pile        &  Holds the cards which are added to the Foundation Pile.\\ \hline
		3  & tFPe\_Clubs\_Add        &  External input for adding cards to the Foundation Pile.  \\ \hline
		4 & tFPe\_Clubs\_Move        &  External input for the move-command. \\ \hline
		5 & tFPe\_Clubs\_Out         &  External output  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Tableau Pile Module}
The Tableau Pile module is depicted in figure \ref{fig:tableau_pile}. It is duplicated 7 times, once for every pile in the tableau. The main difference between these modules is the names of their respective transitions and names, so the description given for the first pile will count for the other duplicates as well. Another difference is how many cards each pile are dealt during the initial phase. This is discussed in more detail in chapter \ref{sec:3_initial_dealing} and \ref{sec:draw_pile}. All the pre- and post-processor files are shared between all piles.
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/tableauPile}
		\caption{Tableau Pile Module}
		\label{fig:tableau_pile}
	\end{center}
\end{figure}

As with the Draw Pile module, the module encompasses both a face-down and a face-up pile. The inner workings between these two piles is different however, as moving a card from the face-down pile to the face-up pile is an non-reversible action. Doing so could put the game in an unsolvable state, but at the same time if there were no cards in any of the face-down piles the game would be trivial to solve. \\

The only time it's possible to add cards to \verb!pTP_1_FaceDown_Pile! is during the initial phase. During this phase one less than the piles identification number will be added, so that pile one will have zero cards in the face-down pile, whilst pile 7 will have 6. This is discussed in more detail in chapter \ref{sec:3_initial_dealing}. All the piles will have a single card added to \verb!pTP_1_FaceUp_Pile!.  
\begin{table}
	\caption{Places and transitions used in Tableau Pile - 1}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pTP\_1\_FaceDown\_Pile    &  \\ \hline
		2 & pTP\_1\_FaceUp\_Pile      &  \\ \hline
		3 & pTP\_1\_Move              &  \\ \hline
		4 & tTPe\_1\_Add\_FaceDown   &    \\ \hline
		5 & tTPe\_1\_Add\_FaceUp     &    \\ \hline
		6 & tTPe\_1\_Move            &    \\ \hline
		7 & tTPe\_1\_Out             &    \\ \hline
		8 & tTPe\_1\_Turn            &    \\ \hline
		9 & tTPi\_1\_Move\_Multiple  &    \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Module Connector Module}
\begin{table}
	\caption{Places and transitions used in Module Connector}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pMC\_DP\_Move             &  \\ \hline
		2 & pMC\_DP\_Turn             &  \\ \hline
		3 & pMC\_FP\_Move             &  \\ \hline
		4 & pMC\_Out\_Buffer          &  \\ \hline
		5 & pMC\_TP\_Move             &  \\ \hline
		6 & pMC\_TP\_Turn             &  \\ \hline
		7 & tMC\_DP\_Move\_Siphon     &  \\ \hline
		8 & tMC\_FP\_Move\_Siphon     &  \\ \hline
		9 & tMC\_Out\_Buffer\_Siphon  &  \\ \hline
		10 & tMC\_TP\_Move\_Siphon     &  \\ \hline
		11 & tMC\_TP\_Turn\_Siphon     &  \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Player Module}
\begin{table}
	\caption{Transitions used in Player}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & tPe\_DP\_Move            &    \\ \hline
		2 & tPe\_DP\_Turn            &    \\ \hline
		3 & tPe\_FP\_Clubs\_Move     &    \\ \hline
		4 & tPe\_FP\_Diamonds\_Move  &    \\ \hline
		5 & tPe\_FP\_Hearts\_Move    &    \\ \hline
		6 & tPe\_FP\_Spades\_Move    &    \\ \hline
		7 & tPe\_TP\_1\_Move         &    \\ \hline
		8 & tPe\_TP\_1\_Turn         &    \\ \hline
		9 & tPe\_TP\_2\_Move         &    \\ \hline
		10 & tPe\_TP\_2\_Turn         &    \\ \hline
		11 & tPe\_TP\_3\_Move         &    \\ \hline
		12 & tPe\_TP\_3\_Turn         &    \\ \hline
		13 & tPe\_TP\_4\_Move         &    \\ \hline
		14 & tPe\_TP\_4\_Turn         &    \\ \hline
		15 & tPe\_TP\_5\_Move         &    \\ \hline
		16 & tPe\_TP\_5\_Turn         &    \\ \hline
		17 & tPe\_TP\_6\_Move         &    \\ \hline
		18 & tPe\_TP\_6\_Turn         &    \\ \hline
		19 & tPe\_TP\_7\_Move         &    \\ \hline
		20 & tPe\_TP\_7\_Turn         &    \\ \hline
	\end{tabular}
\end{table}
\clearpage
\subsection{Player Bot Module}
\begin{table}
	\caption{Places and transitions used in Player Bot}
	\begin{tabular}{|l|l|l|}
		\hline
		& Name & Description \\
		\hline
		1 & pPB\_Cmd          &  \\ \hline
		2 & tPBe\_DP\_Move    &  \\ \hline
		3 & tPBe\_DP\_Turn    &  \\ \hline
		4 & tPBe\_FP\_Move    &  \\ \hline
		5 & tPBe\_TP\_Move    &  \\ \hline
		6 & tPBe\_TP\_Turn    &  \\ \hline
		7 & tPBi\_Gen         &  \\ \hline
		8 & tPBi\_Siphon      &  \\ \hline
	\end{tabular}
\end{table}
*tPBi\_Gen\_Stop is deleted. But code is still there. Make comment on why this is removed*
\clearpage
\section{Implementation}
\label{sec:3_implementation}
\subsection{\ac{gui}}
\label{sec:3_gui}
\clearpage
\subsection{Algorithms}
\subsubsection{Atomicity}
\clearpage
\subsection{Commands}
\subsubsection{Move Command}~\\~\\
\label{sec:3_move_command}
The move command is contains four parts; the command, destination, source and amount. Each part is concatenated together, with colon as a separator. An example of a move command would be: \textit{Move:\ac{tp}1:\ac{tp}5:3}, which means \textit{Move 3 cards from \ac{tp}1 to \ac{tp}5}. If amount is not given, it will assume one card to be moved.
\newline

In order to make sure that only validity of the move-commands, the function \verb!checkCommand_Move! has been developed. It is used both for validation before sending a command, and validation after receiving a command. The function takes the input parameters; \verb!command!, \verb!destination!, \verb!source!, and \verb!handle_err!. 
\newline

The input parameter \verb!command! contains the actual command, \verb!destination! contains the unique identifiers of the \ac{fp} or \ac{tp} modules. Valid input for \verb!destination! would be \textit{C, D, H, S, 1, 2, 3, 4, 5, 6 or 7}, and is used to ensure that the command is received by the destined module. Parameter \verb!source! is only used when sending a command, and contains the actual name of the transition which issued the game. This is mainly used to set the variable \verb!global_info.last_command_source! which will be the name of the transition holding the \verb!playerAction! resource. Resources are discussed in more detail in chapter \ref{sec:3_Resources}. Lastly, the parameter \verb!handle_err! holds the GUI-component where error mesasges will be written. Full code for the function can be found in the appendix, at chapter \ref{app:checkCommand_Move.m}.
\\

Figure \ref{fig:checkCommand_Move} shows a flowchart of the logic in the function.
\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{images/checkCommand_Move}
		\caption{Flowchart - checkCommand\_Move}
		\label{fig:checkCommand_Move}
	\end{center}
\end{figure}
\clearpage
\subsection{Initial Dealing}
\subsection{Resources}
\label{sec:3_Resources}
\subsection{Moving Multiple Cards}
\subsection{Scoring}
\subsection{Possible improvments}
A major drawback of the siphon \verb!tMC_Out_Buffer_Siphon! is that if it fires, the card will actually be removed from the game, and the game becomes unsolvable. This transition will fire if the move-command of the token has an invalid destination. Due to how the Player and Player Bot modules are set up, this will never happen as they will check the validity of the move command before actually issuing the command. Still, I think it would be an improvement add an additional transition to the Draw Pile module which would accept cards from \verb!tMC_Out_Buffer_Siphon!, instead of totally discarding them.
\newline

Another improvement would be to refactor the codebase by moving more of the validity check of the commands from the Player and Player Bot modules to the destination transitions. The Player Bot modules uses roughly 200 lines of code to always issue valid commands, I think this could be drastically reduced. By doing this it would be easier to create additional modules which could interface with the game, for example a hardware-based module.

\begin{verbatim}
    def mapper_from_to(self, key, email):
        if 'to' in email.keys() and 'from' in email.keys() and 'body_count' in email.keys():
\end{verbatim}

\section{Testing, Analysis and Results}
\subsection{Matlab version}
The project has been developed and tested in versions R2013b and R2017a. Due to using two versions of Matlab it was necessary to only use functionality that is supported in both versions. Examples of this is using \verb!GUIDE! for developing the GUI, and omitting to use the \verb!contains! command.
\label{sec:3_testing_analysis}
\subsection{Algorithms}
\subsubsection{Atomicity}
In order to preventdd
\subsection{Initial Dealing}
\label{sec:3_initial_dealing}
\subsection{Resources}
\subsection{Moving Multiple Cards}

\section{Discussion}



% Keeping this for reference for now %
\begin{thebibliography}{6}

\bibitem{wikiTFIDF} Wikipedia article on Tf-idf. \url{https://en.wikipedia.org/wiki/Tf?idf}
\bibitem{oreilly} Tom White, Hadoop: The Definitive Guide, 2015, \emph{ISBN: 978-1-491-90163-2}
\bibitem{dockerdocs} Docker API Docs, \url{https://docs.docker.com}
\bibitem{dat630slides} Slides from DAT630, Krisztian Balog
\bibitem{dataset} Kaggle. The Enron Email Dataset. \url{https://www.kaggle.com/wcukierski/enron-email-dataset}
\bibitem{coursematerial} Data Intensive Systems Compendium, Tomasz Wiktorski et al.

\end{thebibliography}
\addtocmark{Appendix}
\appendix
\section{Overall design - horizontal view}
\begin{figure}
	\label{fig:full_vertical}
	% Left, Bottom, Right, Top
	\includegraphics[trim=40 100 100 310,angle=90,scale=1.4]{images/overallViewPdf}
	\caption{The complete model in horizontal view}
\end{figure}
\clearpage
\section{Matlab code}	
\subsection{checkCommand\_Move.m}
\label{app:checkCommand_Move.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/checkCommand_Move.m}

\subsection{COMMON\_POST.m}
\label{app:COMMON_POST.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/COMMON_POST.m}

\subsection{COMMON\_PRE.m}
\label{app:COMMON_PRE.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/COMMON_PRE.m}

\subsection{draw\_pile\_pdf.m}
\label{app:draw_pile_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/draw_pile_pdf.m}

\subsection{foundation\_pile\_clubs\_pdf.m}
\label{app:foundation_pile_clubs_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_clubs_pdf.m}

\subsection{foundation\_pile\_diamonds\_pdf.m}
\label{app:foundation_pile_diamonds_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_diamonds_pdf.m}

\subsection{foundation\_pile\_hearts\_pdf.m}
\label{app:foundation_pile_hearts_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_hearts_pdf.m}

\subsection{foundation\_pile\_spades\_pdf.m}
\label{app:foundation_pile_spades_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/foundation_pile_spades_pdf.m}

\subsection{get\_handle.m}
\label{app:get_handle.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_handle.m}

\subsection{get\_suit\_from\_transname.m}
\label{app:get_suit_from_transname.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_suit_from_transname.m}

\subsection{get\_tableau\_from\_transname.m}
\label{app:get_tableau_from_transname.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/get_tableau_from_transname.m}

\subsection{main\_simulation\_file.m}
\label{app:main_simulation_file.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/main_simulation_file.m}

\subsection{module\_connector\_pdf.m}
\label{app:module_connector_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/module_connector_pdf.m}

\subsection{player\_bot\_pdf.m}
\label{app:player_bot_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_bot_pdf.m}

\subsection{player\_GUI.m}
\label{app:player_GUI.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_GUI.m}

\subsection{player\_pdf.m}
\label{app:player_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_pdf.m}

\subsection{player\_update\_GUI.m}
\label{app:player_update_GUI.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/player_update_GUI.m}

\subsection{post\_tTPe\_Add\_FaceUp.m}
\label{app:post_tTPe_Add_FaceUp.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/post_tTPe_Add_FaceUp.m}

\subsection{pre\_tFPe\_Add.m}
\label{app:pre_tFPe_Add.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Add.m}

\subsection{pre\_tFPe\_Move.m}
\label{app:pre_tFPe_Move.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Move.m}

\subsection{pre\_tFPe\_Out.m}
\label{app:pre_tFPe_Out.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tFPe_Out.m}

\subsection{pre\_tPe\_FP\_Move.m}
\label{app:pre_tPe_FP_Move.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_FP_Move.m}

\subsection{pre\_tPe\_TP\_Move.m}
\label{app:pre_tPe_TP_Move.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_TP_Move.m}

\subsection{pre\_tPe\_TP\_Turn.m}
\label{app:pre_tPe_TP_Turn.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tPe_TP_Turn.m}

\subsection{pre\_tTPe\_Add\_FaceDown.m}
\label{app:pre_tTPe_Add_FaceDown.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Add_FaceDown.m}

\subsection{pre\_tTPe\_Add\_FaceUp.m}
\label{app:pre_tTPe_Add_FaceUp.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Add_FaceUp.m}

\subsection{pre\_tTPe\_Move.m}
\label{app:pre_tTPe_Move.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Move.m}

\subsection{pre\_tTPe\_Out.m}
\label{app:pre_tTPe_Out.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Out.m}

\subsection{pre\_tTPe\_Turn.m}
\label{app:pre_tTPe_Turn.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPe_Turn.m}

\subsection{pre\_tTPi\_Move\_Multiple.m}
\label{app:pre_tTPi_Move_Multiple.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/pre_tTPi_Move_Multiple.m}

\subsection{set\_handle.m}
\label{app:set_handle.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/set_handle.m}

\subsection{splitCommand.m}
\label{app:splitCommand.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/splitCommand.m}

\subsection{tableau\_pile\_1\_pdf.m}
\label{app:tableau_pile_1_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_1_pdf.m}

\subsection{tableau\_pile\_2\_pdf.m}
\label{app:tableau_pile_2_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_2_pdf.m}

\subsection{tableau\_pile\_3\_pdf.m}
\label{app:tableau_pile_3_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_3_pdf.m}

\subsection{tableau\_pile\_4\_pdf.m}
\label{app:tableau_pile_4_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_4_pdf.m}

\subsection{tableau\_pile\_5\_pdf.m}
\label{app:tableau_pile_5_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_5_pdf.m}

\subsection{tableau\_pile\_6\_pdf.m}
\label{app:tableau_pile_6_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_6_pdf.m}

\subsection{tableau\_pile\_7\_pdf.m}
\label{app:tableau_pile_7_pdf.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tableau_pile_7_pdf.m}

\subsection{tDPe\_Move\_pre.m}
\label{app:tDPe_Move_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPe_Move_pre.m}

\subsection{tDPe\_Out\_pre.m}
\label{app:tDPe_Out_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPe_Out_pre.m}

\subsection{tDPi\_Dealer\_pre.m}
\label{app:tDPi_Dealer_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Dealer_pre.m}

\subsection{tDPi\_Enable\_FP\_Trans\_post.m}
\label{app:tDPi_Enable_FP_Trans_post.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Enable_FP_Trans_post.m}

\subsection{tDPi\_Flip\_Pile\_post.m}
\label{app:tDPi_Flip_Pile_post.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Flip_Pile_post.m}

\subsection{tDPi\_Flip\_Pile\_pre.m}
\label{app:tDPi_Flip_Pile_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Flip_Pile_pre.m}

\subsection{tDPi\_Move\_Init\_pre.m}
\label{app:tDPi_Move_Init_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Move_Init_pre.m}

\subsection{tDPi\_Turn\_post.m}
\label{app:tDPi_Turn_post.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Turn_post.m}

\subsection{tDPi\_Turn\_pre.m}
\label{app:tDPi_Turn_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tDPi_Turn_pre.m}

\subsection{tMC\_DP\_Move\_Siphon\_pre.m}
\label{app:tMC_DP_Move_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_DP_Move_Siphon_pre.m}

\subsection{tMC\_FP\_Move\_Siphon\_pre.m}
\label{app:tMC_FP_Move_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_FP_Move_Siphon_pre.m}

\subsection{tMC\_Out\_Buffer\_Siphon\_pre.m}
\label{app:tMC_Out_Buffer_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_Out_Buffer_Siphon_pre.m}

\subsection{tMC\_TP\_Move\_Siphon\_pre.m}
\label{app:tMC_TP_Move_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_TP_Move_Siphon_pre.m}

\subsection{tMC\_TP\_Turn\_Siphon\_pre.m}
\label{app:tMC_TP_Turn_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tMC_TP_Turn_Siphon_pre.m}

\subsection{tPBe\_DP\_Move\_pre.m}
\label{app:tPBe_DP_Move_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_DP_Move_pre.m}

\subsection{tPBe\_DP\_Turn\_pre.m}
\label{app:tPBe_DP_Turn_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_DP_Turn_pre.m}

\subsection{tPBe\_FP\_Move\_pre.m}
\label{app:tPBe_FP_Move_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_FP_Move_pre.m}

\subsection{tPBe\_TP\_Move\_pre.m}
\label{app:tPBe_TP_Move_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_TP_Move_pre.m}

\subsection{tPBe\_TP\_Turn\_pre.m}
\label{app:tPBe_TP_Turn_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBe_TP_Turn_pre.m}

\subsection{tPBi\_Gen\_pre.m}
\label{app:tPBi_Gen_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Gen_pre.m}

\subsection{tPBi\_Gen\_Stop\_pre.m}
\label{app:tPBi_Gen_Stop_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Gen_Stop_pre.m}

\subsection{tPBi\_Siphon\_pre.m}
\label{app:tPBi_Siphon_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPBi_Siphon_pre.m}

\subsection{tPe\_DP\_Move\_pre.m}
\label{app:tPe_DP_Move_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPe_DP_Move_pre.m}

\subsection{tPe\_DP\_Turn\_pre.m}
\label{app:tPe_DP_Turn_pre.m}
\lstinputlisting[style=matlabcode]{\GPenSIM/tPe_DP_Turn_pre.m}

\end{document}
